// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.1
// source: xchain.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MXchainClient is the client API for MXchain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MXchainClient interface {
	// SelectUTXOBySize merge many utxos into a few of utxos
	SelectUTXOBySize(ctx context.Context, in *UtxoInput, opts ...grpc.CallOption) (*UtxoOutput, error)
	// PostTx post Transaction to a node
	PostTx(ctx context.Context, in *TxStatus, opts ...grpc.CallOption) (*CommonReply, error)
	QueryACL(ctx context.Context, in *AclStatus, opts ...grpc.CallOption) (*AclStatus, error)
	QueryUtxoRecord(ctx context.Context, in *UtxoRecordDetail, opts ...grpc.CallOption) (*UtxoRecordDetail, error)
	QueryContractStatData(ctx context.Context, in *ContractStatDataRequest, opts ...grpc.CallOption) (*ContractStatDataResponse, error)
	GetAccountContracts(ctx context.Context, in *GetAccountContractsRequest, opts ...grpc.CallOption) (*GetAccountContractsResponse, error)
	// QueryTx query Transaction by TxStatus,
	// Bcname and Txid are required for this
	QueryTx(ctx context.Context, in *TxStatus, opts ...grpc.CallOption) (*TxStatus, error)
	// GetBalance get balance of an address,
	// Address is required for this
	GetBalance(ctx context.Context, in *AddressStatus, opts ...grpc.CallOption) (*AddressStatus, error)
	// GetFrozenBalance get two kinds of balance
	// 1. Still be frozen of an address
	// 2. Available now of an address
	// Address is required for this
	GetBalanceDetail(ctx context.Context, in *AddressBalanceStatus, opts ...grpc.CallOption) (*AddressBalanceStatus, error)
	// GetFrozenBalance get balance that still be frozen of an address,
	// Address is required for this
	GetFrozenBalance(ctx context.Context, in *AddressStatus, opts ...grpc.CallOption) (*AddressStatus, error)
	// GetBlock get block by blockid and return if the block in trunk or in branch
	GetBlock(ctx context.Context, in *BlockID, opts ...grpc.CallOption) (*Block, error)
	// GetBlockByHeight get block by height and return if the block in trunk or in
	// branch
	GetBlockByHeight(ctx context.Context, in *BlockHeight, opts ...grpc.CallOption) (*Block, error)
	GetBlockChainStatus(ctx context.Context, in *BCStatus, opts ...grpc.CallOption) (*BCStatus, error)
	// Get blockchains query blockchains
	GetBlockChains(ctx context.Context, in *CommonIn, opts ...grpc.CallOption) (*BlockChains, error)
	// GetSystemStatus query system status
	GetSystemStatus(ctx context.Context, in *CommonIn, opts ...grpc.CallOption) (*SystemsStatusReply, error)
	// GetConsensusChains query consensus status
	GetConsensusStatus(ctx context.Context, in *ConsensusStatRequest, opts ...grpc.CallOption) (*ConsensusStatus, error)
	// GetNetURL return net url
	GetNetURL(ctx context.Context, in *CommonIn, opts ...grpc.CallOption) (*RawUrl, error)
	// 新的Select utxos接口, 不需要签名，可以支持选择账户的utxo
	SelectUTXO(ctx context.Context, in *UtxoInput, opts ...grpc.CallOption) (*UtxoOutput, error)
	// PreExecWithSelectUTXO preExec & selectUtxo
	PreExecWithSelectUTXO(ctx context.Context, in *PreExecWithSelectUTXORequest, opts ...grpc.CallOption) (*PreExecWithSelectUTXOResponse, error)
	//  DposCandidates get all candidates of the tdpos consensus
	DposCandidates(ctx context.Context, in *DposCandidatesRequest, opts ...grpc.CallOption) (*DposCandidatesResponse, error)
	//  DposNominateRecords get all records nominated by an user
	DposNominateRecords(ctx context.Context, in *DposNominateRecordsRequest, opts ...grpc.CallOption) (*DposNominateRecordsResponse, error)
	//  DposNomineeRecords get nominated record of a candidate
	DposNomineeRecords(ctx context.Context, in *DposNomineeRecordsRequest, opts ...grpc.CallOption) (*DposNomineeRecordsResponse, error)
	//  DposVoteRecords get all vote records voted by an user
	DposVoteRecords(ctx context.Context, in *DposVoteRecordsRequest, opts ...grpc.CallOption) (*DposVoteRecordsResponse, error)
	//  DposVotedRecords get all vote records of a candidate
	DposVotedRecords(ctx context.Context, in *DposVotedRecordsRequest, opts ...grpc.CallOption) (*DposVotedRecordsResponse, error)
	//  DposCheckResults get check results of a specific term
	DposCheckResults(ctx context.Context, in *DposCheckResultsRequest, opts ...grpc.CallOption) (*DposCheckResultsResponse, error)
	// DposStatus get dpos status
	DposStatus(ctx context.Context, in *DposStatusRequest, opts ...grpc.CallOption) (*DposStatusResponse, error)
	// GetAccountByAK get account sets contain a specific address
	GetAccountByAK(ctx context.Context, in *AK2AccountRequest, opts ...grpc.CallOption) (*AK2AccountResponse, error)
	// GetAddressContracts get contracts of accounts contain a specific address
	GetAddressContracts(ctx context.Context, in *AddressContractsRequest, opts ...grpc.CallOption) (*AddressContractsResponse, error)
	//预执行合约
	PreExec(ctx context.Context, in *InvokeRPCRequest, opts ...grpc.CallOption) (*InvokeRPCResponse, error)
}

type mXchainClient struct {
	cc grpc.ClientConnInterface
}

func NewMXchainClient(cc grpc.ClientConnInterface) MXchainClient {
	return &mXchainClient{cc}
}

func (c *mXchainClient) SelectUTXOBySize(ctx context.Context, in *UtxoInput, opts ...grpc.CallOption) (*UtxoOutput, error) {
	out := new(UtxoOutput)
	err := c.cc.Invoke(ctx, "/pb.MXchain/SelectUTXOBySize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) PostTx(ctx context.Context, in *TxStatus, opts ...grpc.CallOption) (*CommonReply, error) {
	out := new(CommonReply)
	err := c.cc.Invoke(ctx, "/pb.MXchain/PostTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) QueryACL(ctx context.Context, in *AclStatus, opts ...grpc.CallOption) (*AclStatus, error) {
	out := new(AclStatus)
	err := c.cc.Invoke(ctx, "/pb.MXchain/QueryACL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) QueryUtxoRecord(ctx context.Context, in *UtxoRecordDetail, opts ...grpc.CallOption) (*UtxoRecordDetail, error) {
	out := new(UtxoRecordDetail)
	err := c.cc.Invoke(ctx, "/pb.MXchain/QueryUtxoRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) QueryContractStatData(ctx context.Context, in *ContractStatDataRequest, opts ...grpc.CallOption) (*ContractStatDataResponse, error) {
	out := new(ContractStatDataResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/QueryContractStatData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetAccountContracts(ctx context.Context, in *GetAccountContractsRequest, opts ...grpc.CallOption) (*GetAccountContractsResponse, error) {
	out := new(GetAccountContractsResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetAccountContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) QueryTx(ctx context.Context, in *TxStatus, opts ...grpc.CallOption) (*TxStatus, error) {
	out := new(TxStatus)
	err := c.cc.Invoke(ctx, "/pb.MXchain/QueryTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetBalance(ctx context.Context, in *AddressStatus, opts ...grpc.CallOption) (*AddressStatus, error) {
	out := new(AddressStatus)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetBalanceDetail(ctx context.Context, in *AddressBalanceStatus, opts ...grpc.CallOption) (*AddressBalanceStatus, error) {
	out := new(AddressBalanceStatus)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetBalanceDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetFrozenBalance(ctx context.Context, in *AddressStatus, opts ...grpc.CallOption) (*AddressStatus, error) {
	out := new(AddressStatus)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetFrozenBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetBlock(ctx context.Context, in *BlockID, opts ...grpc.CallOption) (*Block, error) {
	out := new(Block)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetBlockByHeight(ctx context.Context, in *BlockHeight, opts ...grpc.CallOption) (*Block, error) {
	out := new(Block)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetBlockByHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetBlockChainStatus(ctx context.Context, in *BCStatus, opts ...grpc.CallOption) (*BCStatus, error) {
	out := new(BCStatus)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetBlockChainStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetBlockChains(ctx context.Context, in *CommonIn, opts ...grpc.CallOption) (*BlockChains, error) {
	out := new(BlockChains)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetBlockChains", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetSystemStatus(ctx context.Context, in *CommonIn, opts ...grpc.CallOption) (*SystemsStatusReply, error) {
	out := new(SystemsStatusReply)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetSystemStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetConsensusStatus(ctx context.Context, in *ConsensusStatRequest, opts ...grpc.CallOption) (*ConsensusStatus, error) {
	out := new(ConsensusStatus)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetConsensusStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetNetURL(ctx context.Context, in *CommonIn, opts ...grpc.CallOption) (*RawUrl, error) {
	out := new(RawUrl)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetNetURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) SelectUTXO(ctx context.Context, in *UtxoInput, opts ...grpc.CallOption) (*UtxoOutput, error) {
	out := new(UtxoOutput)
	err := c.cc.Invoke(ctx, "/pb.MXchain/SelectUTXO", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) PreExecWithSelectUTXO(ctx context.Context, in *PreExecWithSelectUTXORequest, opts ...grpc.CallOption) (*PreExecWithSelectUTXOResponse, error) {
	out := new(PreExecWithSelectUTXOResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/PreExecWithSelectUTXO", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) DposCandidates(ctx context.Context, in *DposCandidatesRequest, opts ...grpc.CallOption) (*DposCandidatesResponse, error) {
	out := new(DposCandidatesResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/DposCandidates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) DposNominateRecords(ctx context.Context, in *DposNominateRecordsRequest, opts ...grpc.CallOption) (*DposNominateRecordsResponse, error) {
	out := new(DposNominateRecordsResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/DposNominateRecords", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) DposNomineeRecords(ctx context.Context, in *DposNomineeRecordsRequest, opts ...grpc.CallOption) (*DposNomineeRecordsResponse, error) {
	out := new(DposNomineeRecordsResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/DposNomineeRecords", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) DposVoteRecords(ctx context.Context, in *DposVoteRecordsRequest, opts ...grpc.CallOption) (*DposVoteRecordsResponse, error) {
	out := new(DposVoteRecordsResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/DposVoteRecords", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) DposVotedRecords(ctx context.Context, in *DposVotedRecordsRequest, opts ...grpc.CallOption) (*DposVotedRecordsResponse, error) {
	out := new(DposVotedRecordsResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/DposVotedRecords", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) DposCheckResults(ctx context.Context, in *DposCheckResultsRequest, opts ...grpc.CallOption) (*DposCheckResultsResponse, error) {
	out := new(DposCheckResultsResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/DposCheckResults", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) DposStatus(ctx context.Context, in *DposStatusRequest, opts ...grpc.CallOption) (*DposStatusResponse, error) {
	out := new(DposStatusResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/DposStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetAccountByAK(ctx context.Context, in *AK2AccountRequest, opts ...grpc.CallOption) (*AK2AccountResponse, error) {
	out := new(AK2AccountResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetAccountByAK", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) GetAddressContracts(ctx context.Context, in *AddressContractsRequest, opts ...grpc.CallOption) (*AddressContractsResponse, error) {
	out := new(AddressContractsResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/GetAddressContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXchainClient) PreExec(ctx context.Context, in *InvokeRPCRequest, opts ...grpc.CallOption) (*InvokeRPCResponse, error) {
	out := new(InvokeRPCResponse)
	err := c.cc.Invoke(ctx, "/pb.MXchain/PreExec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MXchainServer is the server API for MXchain service.
// All implementations should embed UnimplementedMXchainServer
// for forward compatibility
type MXchainServer interface {
	// SelectUTXOBySize merge many utxos into a few of utxos
	SelectUTXOBySize(context.Context, *UtxoInput) (*UtxoOutput, error)
	// PostTx post Transaction to a node
	PostTx(context.Context, *TxStatus) (*CommonReply, error)
	QueryACL(context.Context, *AclStatus) (*AclStatus, error)
	QueryUtxoRecord(context.Context, *UtxoRecordDetail) (*UtxoRecordDetail, error)
	QueryContractStatData(context.Context, *ContractStatDataRequest) (*ContractStatDataResponse, error)
	GetAccountContracts(context.Context, *GetAccountContractsRequest) (*GetAccountContractsResponse, error)
	// QueryTx query Transaction by TxStatus,
	// Bcname and Txid are required for this
	QueryTx(context.Context, *TxStatus) (*TxStatus, error)
	// GetBalance get balance of an address,
	// Address is required for this
	GetBalance(context.Context, *AddressStatus) (*AddressStatus, error)
	// GetFrozenBalance get two kinds of balance
	// 1. Still be frozen of an address
	// 2. Available now of an address
	// Address is required for this
	GetBalanceDetail(context.Context, *AddressBalanceStatus) (*AddressBalanceStatus, error)
	// GetFrozenBalance get balance that still be frozen of an address,
	// Address is required for this
	GetFrozenBalance(context.Context, *AddressStatus) (*AddressStatus, error)
	// GetBlock get block by blockid and return if the block in trunk or in branch
	GetBlock(context.Context, *BlockID) (*Block, error)
	// GetBlockByHeight get block by height and return if the block in trunk or in
	// branch
	GetBlockByHeight(context.Context, *BlockHeight) (*Block, error)
	GetBlockChainStatus(context.Context, *BCStatus) (*BCStatus, error)
	// Get blockchains query blockchains
	GetBlockChains(context.Context, *CommonIn) (*BlockChains, error)
	// GetSystemStatus query system status
	GetSystemStatus(context.Context, *CommonIn) (*SystemsStatusReply, error)
	// GetConsensusChains query consensus status
	GetConsensusStatus(context.Context, *ConsensusStatRequest) (*ConsensusStatus, error)
	// GetNetURL return net url
	GetNetURL(context.Context, *CommonIn) (*RawUrl, error)
	// 新的Select utxos接口, 不需要签名，可以支持选择账户的utxo
	SelectUTXO(context.Context, *UtxoInput) (*UtxoOutput, error)
	// PreExecWithSelectUTXO preExec & selectUtxo
	PreExecWithSelectUTXO(context.Context, *PreExecWithSelectUTXORequest) (*PreExecWithSelectUTXOResponse, error)
	//  DposCandidates get all candidates of the tdpos consensus
	DposCandidates(context.Context, *DposCandidatesRequest) (*DposCandidatesResponse, error)
	//  DposNominateRecords get all records nominated by an user
	DposNominateRecords(context.Context, *DposNominateRecordsRequest) (*DposNominateRecordsResponse, error)
	//  DposNomineeRecords get nominated record of a candidate
	DposNomineeRecords(context.Context, *DposNomineeRecordsRequest) (*DposNomineeRecordsResponse, error)
	//  DposVoteRecords get all vote records voted by an user
	DposVoteRecords(context.Context, *DposVoteRecordsRequest) (*DposVoteRecordsResponse, error)
	//  DposVotedRecords get all vote records of a candidate
	DposVotedRecords(context.Context, *DposVotedRecordsRequest) (*DposVotedRecordsResponse, error)
	//  DposCheckResults get check results of a specific term
	DposCheckResults(context.Context, *DposCheckResultsRequest) (*DposCheckResultsResponse, error)
	// DposStatus get dpos status
	DposStatus(context.Context, *DposStatusRequest) (*DposStatusResponse, error)
	// GetAccountByAK get account sets contain a specific address
	GetAccountByAK(context.Context, *AK2AccountRequest) (*AK2AccountResponse, error)
	// GetAddressContracts get contracts of accounts contain a specific address
	GetAddressContracts(context.Context, *AddressContractsRequest) (*AddressContractsResponse, error)
	//预执行合约
	PreExec(context.Context, *InvokeRPCRequest) (*InvokeRPCResponse, error)
}

// UnimplementedMXchainServer should be embedded to have forward compatible implementations.
type UnimplementedMXchainServer struct {
}

func (UnimplementedMXchainServer) SelectUTXOBySize(context.Context, *UtxoInput) (*UtxoOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SelectUTXOBySize not implemented")
}
func (UnimplementedMXchainServer) PostTx(context.Context, *TxStatus) (*CommonReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostTx not implemented")
}
func (UnimplementedMXchainServer) QueryACL(context.Context, *AclStatus) (*AclStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryACL not implemented")
}
func (UnimplementedMXchainServer) QueryUtxoRecord(context.Context, *UtxoRecordDetail) (*UtxoRecordDetail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUtxoRecord not implemented")
}
func (UnimplementedMXchainServer) QueryContractStatData(context.Context, *ContractStatDataRequest) (*ContractStatDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryContractStatData not implemented")
}
func (UnimplementedMXchainServer) GetAccountContracts(context.Context, *GetAccountContractsRequest) (*GetAccountContractsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountContracts not implemented")
}
func (UnimplementedMXchainServer) QueryTx(context.Context, *TxStatus) (*TxStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTx not implemented")
}
func (UnimplementedMXchainServer) GetBalance(context.Context, *AddressStatus) (*AddressStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedMXchainServer) GetBalanceDetail(context.Context, *AddressBalanceStatus) (*AddressBalanceStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalanceDetail not implemented")
}
func (UnimplementedMXchainServer) GetFrozenBalance(context.Context, *AddressStatus) (*AddressStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFrozenBalance not implemented")
}
func (UnimplementedMXchainServer) GetBlock(context.Context, *BlockID) (*Block, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedMXchainServer) GetBlockByHeight(context.Context, *BlockHeight) (*Block, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByHeight not implemented")
}
func (UnimplementedMXchainServer) GetBlockChainStatus(context.Context, *BCStatus) (*BCStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockChainStatus not implemented")
}
func (UnimplementedMXchainServer) GetBlockChains(context.Context, *CommonIn) (*BlockChains, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockChains not implemented")
}
func (UnimplementedMXchainServer) GetSystemStatus(context.Context, *CommonIn) (*SystemsStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemStatus not implemented")
}
func (UnimplementedMXchainServer) GetConsensusStatus(context.Context, *ConsensusStatRequest) (*ConsensusStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsensusStatus not implemented")
}
func (UnimplementedMXchainServer) GetNetURL(context.Context, *CommonIn) (*RawUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetURL not implemented")
}
func (UnimplementedMXchainServer) SelectUTXO(context.Context, *UtxoInput) (*UtxoOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SelectUTXO not implemented")
}
func (UnimplementedMXchainServer) PreExecWithSelectUTXO(context.Context, *PreExecWithSelectUTXORequest) (*PreExecWithSelectUTXOResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreExecWithSelectUTXO not implemented")
}
func (UnimplementedMXchainServer) DposCandidates(context.Context, *DposCandidatesRequest) (*DposCandidatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DposCandidates not implemented")
}
func (UnimplementedMXchainServer) DposNominateRecords(context.Context, *DposNominateRecordsRequest) (*DposNominateRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DposNominateRecords not implemented")
}
func (UnimplementedMXchainServer) DposNomineeRecords(context.Context, *DposNomineeRecordsRequest) (*DposNomineeRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DposNomineeRecords not implemented")
}
func (UnimplementedMXchainServer) DposVoteRecords(context.Context, *DposVoteRecordsRequest) (*DposVoteRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DposVoteRecords not implemented")
}
func (UnimplementedMXchainServer) DposVotedRecords(context.Context, *DposVotedRecordsRequest) (*DposVotedRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DposVotedRecords not implemented")
}
func (UnimplementedMXchainServer) DposCheckResults(context.Context, *DposCheckResultsRequest) (*DposCheckResultsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DposCheckResults not implemented")
}
func (UnimplementedMXchainServer) DposStatus(context.Context, *DposStatusRequest) (*DposStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DposStatus not implemented")
}
func (UnimplementedMXchainServer) GetAccountByAK(context.Context, *AK2AccountRequest) (*AK2AccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountByAK not implemented")
}
func (UnimplementedMXchainServer) GetAddressContracts(context.Context, *AddressContractsRequest) (*AddressContractsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressContracts not implemented")
}
func (UnimplementedMXchainServer) PreExec(context.Context, *InvokeRPCRequest) (*InvokeRPCResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreExec not implemented")
}

// UnsafeMXchainServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MXchainServer will
// result in compilation errors.
type UnsafeMXchainServer interface {
	mustEmbedUnimplementedMXchainServer()
}

func RegisterMXchainServer(s grpc.ServiceRegistrar, srv MXchainServer) {
	s.RegisterService(&MXchain_ServiceDesc, srv)
}

func _MXchain_SelectUTXOBySize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UtxoInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).SelectUTXOBySize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/SelectUTXOBySize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).SelectUTXOBySize(ctx, req.(*UtxoInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_PostTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).PostTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/PostTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).PostTx(ctx, req.(*TxStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_QueryACL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).QueryACL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/QueryACL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).QueryACL(ctx, req.(*AclStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_QueryUtxoRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UtxoRecordDetail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).QueryUtxoRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/QueryUtxoRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).QueryUtxoRecord(ctx, req.(*UtxoRecordDetail))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_QueryContractStatData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractStatDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).QueryContractStatData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/QueryContractStatData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).QueryContractStatData(ctx, req.(*ContractStatDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetAccountContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetAccountContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetAccountContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetAccountContracts(ctx, req.(*GetAccountContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_QueryTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).QueryTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/QueryTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).QueryTx(ctx, req.(*TxStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetBalance(ctx, req.(*AddressStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetBalanceDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressBalanceStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetBalanceDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetBalanceDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetBalanceDetail(ctx, req.(*AddressBalanceStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetFrozenBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetFrozenBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetFrozenBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetFrozenBalance(ctx, req.(*AddressStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetBlock(ctx, req.(*BlockID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetBlockByHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHeight)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetBlockByHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetBlockByHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetBlockByHeight(ctx, req.(*BlockHeight))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetBlockChainStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BCStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetBlockChainStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetBlockChainStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetBlockChainStatus(ctx, req.(*BCStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetBlockChains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommonIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetBlockChains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetBlockChains",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetBlockChains(ctx, req.(*CommonIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetSystemStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommonIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetSystemStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetSystemStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetSystemStatus(ctx, req.(*CommonIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetConsensusStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsensusStatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetConsensusStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetConsensusStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetConsensusStatus(ctx, req.(*ConsensusStatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetNetURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommonIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetNetURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetNetURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetNetURL(ctx, req.(*CommonIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_SelectUTXO_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UtxoInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).SelectUTXO(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/SelectUTXO",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).SelectUTXO(ctx, req.(*UtxoInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_PreExecWithSelectUTXO_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreExecWithSelectUTXORequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).PreExecWithSelectUTXO(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/PreExecWithSelectUTXO",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).PreExecWithSelectUTXO(ctx, req.(*PreExecWithSelectUTXORequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_DposCandidates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DposCandidatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).DposCandidates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/DposCandidates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).DposCandidates(ctx, req.(*DposCandidatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_DposNominateRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DposNominateRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).DposNominateRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/DposNominateRecords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).DposNominateRecords(ctx, req.(*DposNominateRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_DposNomineeRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DposNomineeRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).DposNomineeRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/DposNomineeRecords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).DposNomineeRecords(ctx, req.(*DposNomineeRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_DposVoteRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DposVoteRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).DposVoteRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/DposVoteRecords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).DposVoteRecords(ctx, req.(*DposVoteRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_DposVotedRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DposVotedRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).DposVotedRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/DposVotedRecords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).DposVotedRecords(ctx, req.(*DposVotedRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_DposCheckResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DposCheckResultsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).DposCheckResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/DposCheckResults",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).DposCheckResults(ctx, req.(*DposCheckResultsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_DposStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DposStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).DposStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/DposStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).DposStatus(ctx, req.(*DposStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetAccountByAK_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AK2AccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetAccountByAK(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetAccountByAK",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetAccountByAK(ctx, req.(*AK2AccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_GetAddressContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).GetAddressContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/GetAddressContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).GetAddressContracts(ctx, req.(*AddressContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXchain_PreExec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvokeRPCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXchainServer).PreExec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MXchain/PreExec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXchainServer).PreExec(ctx, req.(*InvokeRPCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MXchain_ServiceDesc is the grpc.ServiceDesc for MXchain service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MXchain_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.MXchain",
	HandlerType: (*MXchainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SelectUTXOBySize",
			Handler:    _MXchain_SelectUTXOBySize_Handler,
		},
		{
			MethodName: "PostTx",
			Handler:    _MXchain_PostTx_Handler,
		},
		{
			MethodName: "QueryACL",
			Handler:    _MXchain_QueryACL_Handler,
		},
		{
			MethodName: "QueryUtxoRecord",
			Handler:    _MXchain_QueryUtxoRecord_Handler,
		},
		{
			MethodName: "QueryContractStatData",
			Handler:    _MXchain_QueryContractStatData_Handler,
		},
		{
			MethodName: "GetAccountContracts",
			Handler:    _MXchain_GetAccountContracts_Handler,
		},
		{
			MethodName: "QueryTx",
			Handler:    _MXchain_QueryTx_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _MXchain_GetBalance_Handler,
		},
		{
			MethodName: "GetBalanceDetail",
			Handler:    _MXchain_GetBalanceDetail_Handler,
		},
		{
			MethodName: "GetFrozenBalance",
			Handler:    _MXchain_GetFrozenBalance_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _MXchain_GetBlock_Handler,
		},
		{
			MethodName: "GetBlockByHeight",
			Handler:    _MXchain_GetBlockByHeight_Handler,
		},
		{
			MethodName: "GetBlockChainStatus",
			Handler:    _MXchain_GetBlockChainStatus_Handler,
		},
		{
			MethodName: "GetBlockChains",
			Handler:    _MXchain_GetBlockChains_Handler,
		},
		{
			MethodName: "GetSystemStatus",
			Handler:    _MXchain_GetSystemStatus_Handler,
		},
		{
			MethodName: "GetConsensusStatus",
			Handler:    _MXchain_GetConsensusStatus_Handler,
		},
		{
			MethodName: "GetNetURL",
			Handler:    _MXchain_GetNetURL_Handler,
		},
		{
			MethodName: "SelectUTXO",
			Handler:    _MXchain_SelectUTXO_Handler,
		},
		{
			MethodName: "PreExecWithSelectUTXO",
			Handler:    _MXchain_PreExecWithSelectUTXO_Handler,
		},
		{
			MethodName: "DposCandidates",
			Handler:    _MXchain_DposCandidates_Handler,
		},
		{
			MethodName: "DposNominateRecords",
			Handler:    _MXchain_DposNominateRecords_Handler,
		},
		{
			MethodName: "DposNomineeRecords",
			Handler:    _MXchain_DposNomineeRecords_Handler,
		},
		{
			MethodName: "DposVoteRecords",
			Handler:    _MXchain_DposVoteRecords_Handler,
		},
		{
			MethodName: "DposVotedRecords",
			Handler:    _MXchain_DposVotedRecords_Handler,
		},
		{
			MethodName: "DposCheckResults",
			Handler:    _MXchain_DposCheckResults_Handler,
		},
		{
			MethodName: "DposStatus",
			Handler:    _MXchain_DposStatus_Handler,
		},
		{
			MethodName: "GetAccountByAK",
			Handler:    _MXchain_GetAccountByAK_Handler,
		},
		{
			MethodName: "GetAddressContracts",
			Handler:    _MXchain_GetAddressContracts_Handler,
		},
		{
			MethodName: "PreExec",
			Handler:    _MXchain_PreExec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "xchain.proto",
}
